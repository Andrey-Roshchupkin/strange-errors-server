package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"strange-errors-server/internal/database"
	"strange-errors-server/internal/models"
)

// Handler holds dependencies for HTTP handlers
type Handler struct {
	db *database.DB
}

// New creates a new Handler instance
func New(db *database.DB) *Handler {
	return &Handler{db: db}
}

// GetArticlesHandler handles GET /api/articles - with wrong status code (777 instead of 200)
// @Summary Get all articles
// @Description Retrieves all articles from the database.
// @Tags articles
// @Accept json
// @Produce json
// @Success 777 {object} models.APIResponse "Articles retrieved successfully"
// @Failure 500 {string} string "Database error"
// @Router /api/articles [get]
func (h *Handler) GetArticlesHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "Method not allowed", 405)
		return
	}

	articles, err := h.db.GetArticles()
	if err != nil {
		http.Error(w, "Database error", 500)
		return
	}

	// Wrong status code - should be 200, but we use 777
	w.WriteHeader(777)
	response := models.APIResponse{
		Message: "Data successfully retrieved!",
		Data:    articles,
	}
	json.NewEncoder(w).Encode(response)
}

// CreateArticleHandler handles POST /api/article - with wrong status codes
// @Summary Create a new article
// @Description Creates a new article in the database. ID is generated by the server.
// @Tags articles
// @Accept json
// @Produce json
// @Param article body models.CreateArticleRequest true "Article data (title and content only)"
// @Success 888 {object} models.APIResponse "Article created successfully"
// @Failure 999 {object} models.APIResponse "Invalid request data"
// @Failure 500 {string} string "Database error"
// @Router /api/article [post]
func (h *Handler) CreateArticleHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", 405)
		return
	}

	var articleReq models.CreateArticleRequest
	err := json.NewDecoder(r.Body).Decode(&articleReq)
	if err != nil {
		// Wrong status code - should be 400, but we use 999
		w.WriteHeader(999)
		response := models.APIResponse{
			Error:  "Failed to add article. Both title and content are required.",
			Status: "INCORRECT_REQUEST",
		}
		json.NewEncoder(w).Encode(response)
		return
	}

	if articleReq.Title == "" || articleReq.Content == "" {
		// Wrong status code - should be 400, but we use 999
		w.WriteHeader(999)
		response := models.APIResponse{
			Error:  "Failed to add article. Both title and content are required.",
			Status: "INCORRECT_REQUEST",
		}
		json.NewEncoder(w).Encode(response)
		return
	}

	err = h.db.CreateArticle(articleReq.Title, articleReq.Content)
	if err != nil {
		http.Error(w, "Database error", 500)
		return
	}

	// Wrong status code - should be 201, but we use 888
	w.WriteHeader(888)
	response := models.APIResponse{
		Message: "New article added.",
		Status:  "OK",
	}
	json.NewEncoder(w).Encode(response)
}

// DeleteArticleHandler handles DELETE /api/article/{id} - with wrong status codes
// @Summary Delete an article
// @Description Deletes an article by ID from the database.
// @Tags articles
// @Accept json
// @Produce json
// @Param id path int true "Article ID"
// @Success 200 {object} models.APIResponse "Article deleted successfully"
// @Failure 500 {object} models.APIResponse "Invalid ID format"
// @Failure 666 {object} models.APIResponse "Article not found"
// @Router /api/article/{id} [delete]
func (h *Handler) DeleteArticleHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "DELETE" {
		http.Error(w, "Method not allowed", 405)
		return
	}

	idStr := r.URL.Path[len("/api/article/"):]
	id, err := strconv.Atoi(idStr)
	if err != nil {
		// Wrong status code - should be 400, but we use 500
		w.WriteHeader(500)
		response := models.APIResponse{
			Error:   "We're not even going to check for that. Something went wrong on our end.",
			Message: "Invalid input. We can only delete articles by their numeric ID.",
		}
		json.NewEncoder(w).Encode(response)
		return
	}

	rowsAffected, err := h.db.DeleteArticle(id)
	if err != nil {
		http.Error(w, "Database error", 500)
		return
	}

	if rowsAffected == 0 {
		// Wrong status code - should be 404, but we use 666
		w.WriteHeader(666)
		response := models.APIResponse{
			Message: "No evil articles found to remove.",
			Status:  "FAILURE",
		}
		json.NewEncoder(w).Encode(response)
	} else {
		w.WriteHeader(200)
		response := models.APIResponse{
			Message: fmt.Sprintf("Article with id %d has been removed.", id),
			Status:  "SUCCESS",
		}
		json.NewEncoder(w).Encode(response)
	}
}

// HealthCheckHandler handles GET /api/health-check - regular health check
// @Summary Health check
// @Description Performs a regular health check of the server
// @Tags health
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{} "Server is healthy"
// @Router /api/health-check [get]
func (h *Handler) HealthCheckHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "Method not allowed", 405)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	response := map[string]interface{}{
		"status":    "OK",
		"message":   "Server is running normally.",
		"timestamp": time.Now().Format(time.RFC3339),
	}
	json.NewEncoder(w).Encode(response)
}

// CreateUserHandler handles POST /api/user - idempotent POST method
// @Summary Create a new user (Idempotent POST)
// @Description Creates a new user if the name doesn't already exist. This demonstrates idempotent POST behavior - calling multiple times with the same name will return an error instead of creating duplicates.
// @Tags users
// @Accept json
// @Produce json
// @Param user body models.CreateUserRequest true "User data (name and email required)"
// @Success 201 {object} models.User "User created successfully"
// @Failure 400 {object} models.APIResponse "User already exists or invalid data"
// @Failure 500 {object} models.APIResponse "Internal server error (wrong status for invalid email)"
// @Router /api/user [post]
func (h *Handler) CreateUserHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", 405)
		return
	}

	var user models.CreateUserRequest
	err := json.NewDecoder(r.Body).Decode(&user)
	if err != nil {
		w.WriteHeader(400)
		response := models.APIResponse{
			Error:  "Invalid JSON data",
			Status: "BAD_REQUEST",
		}
		json.NewEncoder(w).Encode(response)
		return
	}

	if user.Name == "" || user.Email == "" {
		w.WriteHeader(400)
		response := models.APIResponse{
			Error:  "User name and email are required",
			Status: "BAD_REQUEST",
		}
		json.NewEncoder(w).Encode(response)
		return
	}

	// Try to create user (idempotent behavior)
	createdUser, err := h.db.CreateUser(user.Name, user.Email)
	if err != nil {
		// Check if it's an email validation error (should be 400 but we return 500)
		if err.Error() == "internal server error" {
			w.WriteHeader(500)
			response := models.APIResponse{
				Error:  "Internal server error: email validation failed",
				Status: "INTERNAL_ERROR",
			}
			json.NewEncoder(w).Encode(response)
			return
		}
		
		// Check if it's a "user already exists" error
		if err.Error() == fmt.Sprintf("user with name '%s' already exists", user.Name) {
			w.WriteHeader(400)
			response := models.APIResponse{
				Error:  fmt.Sprintf("User with name '%s' already exists", user.Name),
				Status: "USER_EXISTS",
			}
			json.NewEncoder(w).Encode(response)
			return
		}
		
		// Other database error
		http.Error(w, "Database error", 500)
		return
	}

	// User created successfully
	w.WriteHeader(201)
	json.NewEncoder(w).Encode(createdUser)
}
