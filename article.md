# The Absence of Errors Double Fallacy: When HTTP Standards Meet Reality

## Introduction: The Interview Paradox

Picture this: you're sitting in an interview, and the interviewer asks, "What HTTP status codes do you know?" or "What's the difference between GET and POST?" Almost every candidate confidently rattles off the same textbook answers: "200 for success, 404 for not found, POST is for creating resources, GET is idempotent..." The responses are so predictable they could be scripted. But here's the thing—after conducting interviews and years of working on real projects, I've discovered something fascinating: the gap between what we _think_ we know about HTTP standards and what actually happens exists and it's very big. In real-world applications, I've seen developers sometimes ignore HTTP conventions to meet business requirements—a POST method that should be idempotent becomes non-idempotent because "the business needs it that way." And sometimes they make mistakes in places where we don't expect.

QA should know about the testing principle "The Absence of Errors Fallacy" but when they answer questions about what status codes and HTTP methods exist, they say what should exist according to official specs, this way making a double fallacy.

This article isn't just another tutorial on HTTP status codes—it's a journey through the strange and wonderful world of how developers actually implement web standards when theory meets reality, complete with real-life examples that will make you question everything you thought you knew about HTTP, and my brand new GOAT method that breaks all the rules but exists.

## The Strange Errors Server

To demonstrate these concepts in action, I've prepared a special demonstration server called "Strange Errors Server" that showcases various HTTP fallacies and unconventional implementations. This server runs on `http://localhost:3000` and includes:

### API Routes

**Articles API (Non-Idempotent POST)**

- `GET /api/articles` - Get all articles
- `POST /api/article` - Create a new article (creates duplicates on repeated calls)
- `DELETE /api/article/{id}` - Delete an article by ID

**Users API (Idempotent POST)**

- `POST /api/user` - Create a new user (returns error if user already exists)

**Health Check**

- `GET /api/health-check` - Regular health check
- `GOAT /api/health-check` - Custom method with progressive behavior

**Documentation**

- `GET /swagger/` - Interactive API documentation
- `GET /swagger/doc.json` - OpenAPI specification

The server demonstrates the difference between idempotent and non-idempotent POST methods, showcases incorrect HTTP status codes, and features the infamous GOAT method that progressively becomes more destructive with each call. Try it yourself to discover what's wrong with the HTTP responses! You can find all the code and README with instructions to run in the repository: https://github.com/Andrey-Roshchupkin/strange-errors-server

## The Idempotency Paradox: When POST Methods Break the Rules

Let's start with idempotency and compare the two POST methods from our server. According to the [HTTP/1.1 specification (RFC 7231)](https://tools.ietf.org/html/rfc7231#section-4.3.3), POST methods are not required to be idempotent, but in practice, many real-world APIs implement them as such for business reasons.

Take payment systems, for example. Both [PayPal](https://developer.paypal.com/docs/api/orders/v2/#orders_create) and [Stripe](https://stripe.com/docs/api/idempotent_requests) use POST methods for payments but implement idempotency through special headers like `Idempotency-Key`. This allows the same payment request to be safely retried without creating duplicate charges.

However, according to REST recommendations, payment systems should ideally use PUT methods with endpoints like `payments/{paymentID}`, where the ID is generated on the frontend. But here's the catch: in this scenario, fraudsters could send millions of PUT requests with random IDs, potentially overwhelming the system with invalid payment attempts. This is why many payment providers stick with POST methods and implement their own idempotency mechanisms instead of following the "pure" REST approach.

Our Strange Errors Server demonstrates this exact dilemma with two different POST implementations:

### Non-Idempotent POST: Articles API

The articles endpoint follows the traditional POST behavior - it creates a new resource every time, even with identical data:

```bash
# First call - creates article (ID generated by server)
curl -X POST -H "Content-Type: application/json" \
  -d '{"title":"Test Article","content":"Test content"}' \
  http://localhost:3000/api/article

# HTTP/1.1 888 OK
# Response: {"message":"New article added.","status":"OK"}

# Second call with same data - creates duplicate (new ID generated)
curl -X POST -H "Content-Type: application/json" \
  -d '{"title":"Test Article","content":"Test content"}' \
  http://localhost:3000/api/article

# HTTP/1.1 888 OK
# Response: {"message":"New article added.","status":"OK"}
```

As you can see, both calls return success, and if we check the articles list, we'll find two identical articles with different IDs. This is the "standard" POST behavior according to HTTP specifications.

### Idempotent POST: Users API

The users endpoint breaks the HTTP rule to follow business logic - it prevents duplicate users:

```bash
# First call - creates user
curl -X POST -H "Content-Type: application/json" \
  -d '{"name":"Alice"}' \
  http://localhost:3000/api/user

# HTTP/1.1 201 Created
# Response: {"id":1,"name":"Alice"}

# Second call with same data - returns error
curl -X POST -H "Content-Type: application/json" \
  -d '{"name":"Alice"}' \
  http://localhost:3000/api/user

# HTTP/1.1 400 Bad Request
# Response: {"message":"","status":"USER_EXISTS","error":"User with name 'Alice' already exists"}
```

Here's where we break the HTTP specification to follow business logic. According to HTTP standards, POST methods should create new resources, but in our case, we're implementing idempotency to prevent duplicate users - a common business requirement that overrides the technical specification.

This is exactly what happens in real-world applications: developers choose business logic over strict HTTP compliance, creating APIs that work better for their specific use cases but deviate from the "pure" REST approach.

## The Status Code Deception: When Errors Hide in Plain Sight

Attentive readers might have noticed something unusual in our examples - the status code `888` instead of the expected `201`. For experienced engineers, this looks obviously wrong, but in real projects, status codes that handle errors can be wrong and not so obvious. It can be subtle error handling mistakes that are hard to spot.

Let's look at our updated user creation endpoint that now includes email validation:

```bash
# Valid email - creates user successfully
curl -X POST -H "Content-Type: application/json" \
  -d '{"name":"ValidUser","email":"valid@example.com"}' \
  http://localhost:3000/api/user

# HTTP/1.1 201 Created
# Response: {"id":1,"name":"ValidUser","email":"valid@example.com"}

# Invalid email - returns wrong status code
curl -X POST -H "Content-Type: application/json" \
  -d '{"name":"InvalidUser","email":"ab"}' \
  http://localhost:3000/api/user

# HTTP/1.1 500 Internal Server Error
# Response: {"message":"","status":"INTERNAL_ERROR","error":"Internal server error: email validation failed"}
```

Here's the problem: when the email validation fails, we return a `500 Internal Server Error` instead of the correct `400 Bad Request`. According to HTTP standards, a `500` error indicates a server-side problem, but email validation failure is clearly a client-side issue that should return `400`.

This type of error handling mistake is surprisingly common in production systems. Developers often return `500` errors for validation failures, either out of habit or because they're treating all errors the same way in their error handling middleware.

### The Honeypot Defense: When Wrong Status Codes Are Intentional

Interestingly, setting wrong status codes can sometimes be a deliberate security tactic called a "honeypot." Some systems intentionally return misleading status codes to confuse potential attackers or scrapers. For example:

- Returning `404 Not Found` instead of `403 Forbidden` to hide the existence of protected resources
- Using `500 Internal Server Error` for rate limiting to make it look like a server problem rather than intentional blocking
- Returning `200 OK` with error messages in the response body to bypass simple status code-based detection

While this can be an effective defense mechanism, it also creates the exact problem we're discussing - status codes that don't match their actual meaning, making debugging and integration more difficult for legitimate users.

## The GOAT Method: When HTTP Standards Meet Creativity

Finally, let's explore our most creative example - the custom `GOAT` HTTP method. This demonstrates how developers can create entirely new HTTP methods when business needs require it:

```bash
# First call to GOAT method
curl -X GOAT http://localhost:3000/api/health-check

# Response: {"status":"OK","message":"Hello! I am a brand new GOAT. Everything is fine."}

# Second call - behavior changes
curl -X GOAT http://localhost:3000/api/health-check

# Response: {"status":"Annoyed","message":"Why are you calling me again?"}
```

As you can see, the GOAT method has progressive behavior that changes with each call. Readers can discover the full behavior of this method by themselves - try calling it multiple times to see what happens!

### The Reality of Custom HTTP Methods

The GOAT method is brand new (joke) and demonstrates an important point: custom HTTP methods are possible and sometimes necessary. However, they come with significant limitations:

- **Browser Support**: Custom methods don't work from browsers - they only support standard methods like GET, POST, PUT, DELETE
- **Framework Limitations**: Many backend frameworks don't allow custom methods by default
- **Proxy and Load Balancer Issues**: Infrastructure components may not understand custom methods
- **Client Library Support**: Most HTTP client libraries expect standard methods

But when developers want or business needs require it, new methods can be created and used. This is particularly common for:

- Very internal APIs that don't need broad compatibility
- Secret data transfer protocols
- Specialized operations that don't fit standard REST patterns
- Legacy system integrations that require specific method names

The key is understanding the trade-offs: custom methods give you flexibility but reduce compatibility and standard tooling support.

## Conclusion: The Absence of Errors Double Fallacy

Throughout this article, we've explored how the gap between HTTP theory and practice creates a perfect storm for QA engineers and developers. We've seen:

1. **Idempotency Paradox**: How business logic often overrides HTTP specifications, making POST methods behave differently than expected
2. **Status Code Deception**: How wrong status codes can be either mistakes or intentional security measures
3. **Custom Method Creativity**: How developers create new HTTP methods when standard ones don't fit their needs

### The Double Fallacy Explained

The "Absence of Errors Double Fallacy" occurs when:

1. **First Fallacy**: QA engineers know about the "Absence of Errors Fallacy" (the principle that the absence of errors doesn't prove correctness)
2. **Second Fallacy**: But they still give textbook answers about HTTP standards, assuming real-world implementations follow the specifications

This creates a dangerous blind spot where experienced professionals confidently state what _should_ happen according to standards, while real systems behave completely differently.

### Why This Matters

In real projects, developers make pragmatic choices that prioritize:

- Business requirements over HTTP purity
- Security through obscurity over standard error codes
- Custom solutions over standard methods
- Performance over strict compliance

As QA engineers, we need to:

- Test according to business needs, not just what the system actually does or what the standards say
- Question our assumptions about HTTP behavior
- Look beyond status codes to understand the real system behavior
- Be prepared for non-standard implementations

### The Takeaway

The next time you're in an interview or working on a project, remember: **Understanding business needs is more important than following industry standards**. HTTP standards are guidelines, not laws. Real systems are messy, creative, and often break the rules for good business reasons. The absence of standard HTTP behavior doesn't mean there are no errors - it means you need to dig deeper to understand what business requirements drove these decisions.

When you encounter non-standard HTTP behavior, ask yourself: "What business need does this serve?" rather than "Why doesn't this follow the standard?" The answer will often reveal the real logic behind seemingly "incorrect" implementations.

Try the Strange Errors Server yourself, explore its endpoints, and discover the fascinating ways developers bend HTTP to meet their needs. You might be surprised by what you find.

---

_The Strange Errors Server is available at: https://github.com/Andrey-Roshchupkin/strange-errors-server_

_Run it locally and explore the endpoints to see these concepts in action._
